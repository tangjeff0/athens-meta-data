{
  "url":"https://api.github.com/repos/athensresearch/athens/issues/44",
  "repository_url":"https://api.github.com/repos/athensresearch/athens",
  "labels_url":"https://api.github.com/repos/athensresearch/athens/issues/44/labels{/name}",
  "comments_url":"https://api.github.com/repos/athensresearch/athens/issues/44/comments",
  "events_url":"https://api.github.com/repos/athensresearch/athens/issues/44/events",
  "html_url":"https://github.com/athensresearch/athens/issues/44",
  "id":615127326,
  "node_id":"MDU6SXNzdWU2MTUxMjczMjY=",
  "number":44,
  "title":"Parse and format markdown-ish syntax",
  "user":{
    "login":"teodorlu",
    "id":5285452,
    "node_id":"MDQ6VXNlcjUyODU0NTI=",
    "avatar_url":"https://avatars0.githubusercontent.com/u/5285452?v=4",
    "gravatar_id":"",
    "url":"https://api.github.com/users/teodorlu",
    "html_url":"https://github.com/teodorlu",
    "followers_url":"https://api.github.com/users/teodorlu/followers",
    "following_url":"https://api.github.com/users/teodorlu/following{/other_user}",
    "gists_url":"https://api.github.com/users/teodorlu/gists{/gist_id}",
    "starred_url":"https://api.github.com/users/teodorlu/starred{/owner}{/repo}",
    "subscriptions_url":"https://api.github.com/users/teodorlu/subscriptions",
    "organizations_url":"https://api.github.com/users/teodorlu/orgs",
    "repos_url":"https://api.github.com/users/teodorlu/repos",
    "events_url":"https://api.github.com/users/teodorlu/events{/privacy}",
    "received_events_url":"https://api.github.com/users/teodorlu/received_events",
    "type":"User",
    "site_admin":false
  },
  "labels":[],
  "state":"open",
  "locked":false,
  "assignee":null,
  "assignees":[],
  "milestone":null,
  "created_at":"2020-05-09 08:52:00 UTC",
  "updated_at":"2020-05-29 19:10:56 UTC",
  "closed_at":null,
  "author_association":"NONE",
  "active_lock_reason":null,
  "body":"Creating an issue for how to work with parsing the markup: how to turn plaintext like `I __very__ much like [[Athens Research]]` into a semantic structure that we can understand.\r\n\r\n### Context & prior work\r\n\r\n- Our very own [parser.cljs][our-parser] seems to be a bit of a work in progress\r\n- [static-roam][static-roam] relies on serial regex replacement, and does [not go through an AST][static-roam-parser]\r\n\r\n[our-parser]: https://github.com/athensresearch/athens/blob/76d0881efd245bceef324bbee90c81f7bc6e78d0/src/cljs/athens/parser.cljs\r\n[static-roam]: https://github.com/TomLisankie/static-roam\r\n[static-roam-parser]: https://github.com/TomLisankie/static-roam/blob/master/src/static_roam/core.clj\r\n\r\n### Ideas\r\n\r\nI think we'll be able to find an elegant solution to this. Instaparse is powerful. I don't think we should try to \"hack some regexes\", as that will cause us problems with recursion.\r\n\r\nDesign proposal:\r\n\r\n- Define our AST structure with Clojure Spec. That way, we get validation & generators\r\n- Define symmetric functions so that `(= source (-> source serialize deserialize))`\r\n- Then we should be able to generate ASTs from [Spec generators][1], run them through a serialize & deserialize sequence, and check that they stay the same.\r\n\r\n[1]: https://clojure.org/guides/spec#_generators\r\n\r\nHoping that we can reflect the same structure in our `Instaparse` parser and in our specs.\r\n\r\nThoughts?\r\n\r\n### Challenges\r\n\r\n- How do we represent incomplete ASTS? We need to allow for opening and not closing brackets. Or do we? How do we put `I like [[Athens Research` (missing `]]`) in an AST?",
  "performed_via_github_app":null,
  "comments":[
    {
      "url":"https://api.github.com/repos/athensresearch/athens/issues/comments/626131645",
      "html_url":"https://github.com/athensresearch/athens/issues/44#issuecomment-626131645",
      "issue_url":"https://api.github.com/repos/athensresearch/athens/issues/44",
      "id":626131645,
      "node_id":"MDEyOklzc3VlQ29tbWVudDYyNjEzMTY0NQ==",
      "user":{
        "login":"teodorlu",
        "id":5285452,
        "node_id":"MDQ6VXNlcjUyODU0NTI=",
        "avatar_url":"https://avatars0.githubusercontent.com/u/5285452?v=4",
        "gravatar_id":"",
        "url":"https://api.github.com/users/teodorlu",
        "html_url":"https://github.com/teodorlu",
        "followers_url":"https://api.github.com/users/teodorlu/followers",
        "following_url":"https://api.github.com/users/teodorlu/following{/other_user}",
        "gists_url":"https://api.github.com/users/teodorlu/gists{/gist_id}",
        "starred_url":"https://api.github.com/users/teodorlu/starred{/owner}{/repo}",
        "subscriptions_url":"https://api.github.com/users/teodorlu/subscriptions",
        "organizations_url":"https://api.github.com/users/teodorlu/orgs",
        "repos_url":"https://api.github.com/users/teodorlu/repos",
        "events_url":"https://api.github.com/users/teodorlu/events{/privacy}",
        "received_events_url":"https://api.github.com/users/teodorlu/received_events",
        "type":"User",
        "site_admin":false
      },
      "created_at":"2020-05-09 08:53:20 UTC",
      "updated_at":"2020-05-09 08:53:20 UTC",
      "author_association":"NONE",
      "body":"I'm currently playing around this this: https://github.com/teodorlu/athens/tree/parser-work/src/cljc/athens",
      "performed_via_github_app":null
    },
    {
      "url":"https://api.github.com/repos/athensresearch/athens/issues/comments/626134461",
      "html_url":"https://github.com/athensresearch/athens/issues/44#issuecomment-626134461",
      "issue_url":"https://api.github.com/repos/athensresearch/athens/issues/44",
      "id":626134461,
      "node_id":"MDEyOklzc3VlQ29tbWVudDYyNjEzNDQ2MQ==",
      "user":{
        "login":"jeroenvandijk",
        "id":27645,
        "node_id":"MDQ6VXNlcjI3NjQ1",
        "avatar_url":"https://avatars1.githubusercontent.com/u/27645?v=4",
        "gravatar_id":"",
        "url":"https://api.github.com/users/jeroenvandijk",
        "html_url":"https://github.com/jeroenvandijk",
        "followers_url":"https://api.github.com/users/jeroenvandijk/followers",
        "following_url":"https://api.github.com/users/jeroenvandijk/following{/other_user}",
        "gists_url":"https://api.github.com/users/jeroenvandijk/gists{/gist_id}",
        "starred_url":"https://api.github.com/users/jeroenvandijk/starred{/owner}{/repo}",
        "subscriptions_url":"https://api.github.com/users/jeroenvandijk/subscriptions",
        "organizations_url":"https://api.github.com/users/jeroenvandijk/orgs",
        "repos_url":"https://api.github.com/users/jeroenvandijk/repos",
        "events_url":"https://api.github.com/users/jeroenvandijk/events{/privacy}",
        "received_events_url":"https://api.github.com/users/jeroenvandijk/received_events",
        "type":"User",
        "site_admin":false
      },
      "created_at":"2020-05-09 09:13:11 UTC",
      "updated_at":"2020-05-09 09:14:04 UTC",
      "author_association":"CONTRIBUTOR",
      "body":"I've commented per sub topic:\r\n\r\n### Parsing\r\nInstaparse is a way better option than regexp. It takes a bit to get used to, but eventually combining regexp's will just become a terrible fragile mess. So +1 on that.\r\n\r\n### Incomplete AST\r\nWhat options do we have? In the backend I can imagine we would treat the incomplete AST just as normal next. On the front end we might have a special parser that has spelling-checker like behaviour, saying this like \"you might want to fix this\". We could also annotate (potentially) incomplete ASTs in the database I guess. This would allow one to fix incorrect AST's every now and then and improve the whole database.\r\n\r\n### Transformation\r\nLike you said, Instaparse still needs a post-processing step to put it in the right data structure. I've used `clojure.spec` for this in the past and it can work, but it also a bit tricky. I wouldn't say it's ideal. \r\n\r\nFor the json import (#31) I was already thinking of experimenting with https://github.com/noprompt/meander to support the transformation from nested maps to datoms. I still need to validate this approach, but I can imagine it can be useful for transforming the ASTs as well. Either way `clojure.spec` should definitely be used to validate the shape of the end result. In the past I've worked with different layers of specs, like compiled form and dsl form. It doesn't have to be one spec layer that does everything.",
      "performed_via_github_app":null
    },
    {
      "url":"https://api.github.com/repos/athensresearch/athens/issues/comments/626140287",
      "html_url":"https://github.com/athensresearch/athens/issues/44#issuecomment-626140287",
      "issue_url":"https://api.github.com/repos/athensresearch/athens/issues/44",
      "id":626140287,
      "node_id":"MDEyOklzc3VlQ29tbWVudDYyNjE0MDI4Nw==",
      "user":{
        "login":"jeroenvandijk",
        "id":27645,
        "node_id":"MDQ6VXNlcjI3NjQ1",
        "avatar_url":"https://avatars1.githubusercontent.com/u/27645?v=4",
        "gravatar_id":"",
        "url":"https://api.github.com/users/jeroenvandijk",
        "html_url":"https://github.com/jeroenvandijk",
        "followers_url":"https://api.github.com/users/jeroenvandijk/followers",
        "following_url":"https://api.github.com/users/jeroenvandijk/following{/other_user}",
        "gists_url":"https://api.github.com/users/jeroenvandijk/gists{/gist_id}",
        "starred_url":"https://api.github.com/users/jeroenvandijk/starred{/owner}{/repo}",
        "subscriptions_url":"https://api.github.com/users/jeroenvandijk/subscriptions",
        "organizations_url":"https://api.github.com/users/jeroenvandijk/orgs",
        "repos_url":"https://api.github.com/users/jeroenvandijk/repos",
        "events_url":"https://api.github.com/users/jeroenvandijk/events{/privacy}",
        "received_events_url":"https://api.github.com/users/jeroenvandijk/received_events",
        "type":"User",
        "site_admin":false
      },
      "created_at":"2020-05-09 09:55:48 UTC",
      "updated_at":"2020-05-09 09:55:48 UTC",
      "author_association":"CONTRIBUTOR",
      "body":"In addition to my comment about Meander, I just found this demo of an implementation of a hiccup parser [here](https://github.com/noprompt/meander/blob/epsilon/examples/hiccup.clj#L40). Pretty impressive",
      "performed_via_github_app":null
    },
    {
      "url":"https://api.github.com/repos/athensresearch/athens/issues/comments/626158049",
      "html_url":"https://github.com/athensresearch/athens/issues/44#issuecomment-626158049",
      "issue_url":"https://api.github.com/repos/athensresearch/athens/issues/44",
      "id":626158049,
      "node_id":"MDEyOklzc3VlQ29tbWVudDYyNjE1ODA0OQ==",
      "user":{
        "login":"teodorlu",
        "id":5285452,
        "node_id":"MDQ6VXNlcjUyODU0NTI=",
        "avatar_url":"https://avatars0.githubusercontent.com/u/5285452?v=4",
        "gravatar_id":"",
        "url":"https://api.github.com/users/teodorlu",
        "html_url":"https://github.com/teodorlu",
        "followers_url":"https://api.github.com/users/teodorlu/followers",
        "following_url":"https://api.github.com/users/teodorlu/following{/other_user}",
        "gists_url":"https://api.github.com/users/teodorlu/gists{/gist_id}",
        "starred_url":"https://api.github.com/users/teodorlu/starred{/owner}{/repo}",
        "subscriptions_url":"https://api.github.com/users/teodorlu/subscriptions",
        "organizations_url":"https://api.github.com/users/teodorlu/orgs",
        "repos_url":"https://api.github.com/users/teodorlu/repos",
        "events_url":"https://api.github.com/users/teodorlu/events{/privacy}",
        "received_events_url":"https://api.github.com/users/teodorlu/received_events",
        "type":"User",
        "site_admin":false
      },
      "created_at":"2020-05-09 11:36:00 UTC",
      "updated_at":"2020-05-09 11:38:12 UTC",
      "author_association":"NONE",
      "body":"Generally agree with all your points. Interesting application of incomplete AST to provide user error messages.\r\n\r\nAlso curious about what you have in mind for meander. I haven't put much thought to AST transformations. ",
      "performed_via_github_app":null
    },
    {
      "url":"https://api.github.com/repos/athensresearch/athens/issues/comments/626298950",
      "html_url":"https://github.com/athensresearch/athens/issues/44#issuecomment-626298950",
      "issue_url":"https://api.github.com/repos/athensresearch/athens/issues/44",
      "id":626298950,
      "node_id":"MDEyOklzc3VlQ29tbWVudDYyNjI5ODk1MA==",
      "user":{
        "login":"teodorlu",
        "id":5285452,
        "node_id":"MDQ6VXNlcjUyODU0NTI=",
        "avatar_url":"https://avatars0.githubusercontent.com/u/5285452?v=4",
        "gravatar_id":"",
        "url":"https://api.github.com/users/teodorlu",
        "html_url":"https://github.com/teodorlu",
        "followers_url":"https://api.github.com/users/teodorlu/followers",
        "following_url":"https://api.github.com/users/teodorlu/following{/other_user}",
        "gists_url":"https://api.github.com/users/teodorlu/gists{/gist_id}",
        "starred_url":"https://api.github.com/users/teodorlu/starred{/owner}{/repo}",
        "subscriptions_url":"https://api.github.com/users/teodorlu/subscriptions",
        "organizations_url":"https://api.github.com/users/teodorlu/orgs",
        "repos_url":"https://api.github.com/users/teodorlu/repos",
        "events_url":"https://api.github.com/users/teodorlu/events{/privacy}",
        "received_events_url":"https://api.github.com/users/teodorlu/received_events",
        "type":"User",
        "site_admin":false
      },
      "created_at":"2020-05-10 09:26:55 UTC",
      "updated_at":"2020-05-10 09:33:30 UTC",
      "author_association":"NONE",
      "body":"> Either way clojure.spec should definitely be used to validate the shape of the end result. In the past I've worked with different layers of specs, like compiled form and dsl form. It doesn't have to be one spec layer that does everything.\r\n\r\nInteresting. Gave me some ideas about incomplete ASTs:\r\n\r\n- Base spec for valid ASTs or strings\r\n- \"Extended frontend spec\" that is `(s/or :valid-ast ::valid-ast :ast-with-spell-check-suggest ::ast-with-spell-check-suggest)` (TODO better names)",
      "performed_via_github_app":null
    },
    {
      "url":"https://api.github.com/repos/athensresearch/athens/issues/comments/626302439",
      "html_url":"https://github.com/athensresearch/athens/issues/44#issuecomment-626302439",
      "issue_url":"https://api.github.com/repos/athensresearch/athens/issues/44",
      "id":626302439,
      "node_id":"MDEyOklzc3VlQ29tbWVudDYyNjMwMjQzOQ==",
      "user":{
        "login":"tomisme",
        "id":7482194,
        "node_id":"MDQ6VXNlcjc0ODIxOTQ=",
        "avatar_url":"https://avatars3.githubusercontent.com/u/7482194?v=4",
        "gravatar_id":"",
        "url":"https://api.github.com/users/tomisme",
        "html_url":"https://github.com/tomisme",
        "followers_url":"https://api.github.com/users/tomisme/followers",
        "following_url":"https://api.github.com/users/tomisme/following{/other_user}",
        "gists_url":"https://api.github.com/users/tomisme/gists{/gist_id}",
        "starred_url":"https://api.github.com/users/tomisme/starred{/owner}{/repo}",
        "subscriptions_url":"https://api.github.com/users/tomisme/subscriptions",
        "organizations_url":"https://api.github.com/users/tomisme/orgs",
        "repos_url":"https://api.github.com/users/tomisme/repos",
        "events_url":"https://api.github.com/users/tomisme/events{/privacy}",
        "received_events_url":"https://api.github.com/users/tomisme/received_events",
        "type":"User",
        "site_admin":false
      },
      "created_at":"2020-05-10 09:58:40 UTC",
      "updated_at":"2020-05-10 09:58:40 UTC",
      "author_association":"MEMBER",
      "body":"https://hazel.org/ are doing some interesting work on running/analyzing incomplete programs using 'holes', could be a (longer term) direction to go in",
      "performed_via_github_app":null
    },
    {
      "url":"https://api.github.com/repos/athensresearch/athens/issues/comments/636139109",
      "html_url":"https://github.com/athensresearch/athens/issues/44#issuecomment-636139109",
      "issue_url":"https://api.github.com/repos/athensresearch/athens/issues/44",
      "id":636139109,
      "node_id":"MDEyOklzc3VlQ29tbWVudDYzNjEzOTEwOQ==",
      "user":{
        "login":"roryokane",
        "id":79168,
        "node_id":"MDQ6VXNlcjc5MTY4",
        "avatar_url":"https://avatars0.githubusercontent.com/u/79168?v=4",
        "gravatar_id":"",
        "url":"https://api.github.com/users/roryokane",
        "html_url":"https://github.com/roryokane",
        "followers_url":"https://api.github.com/users/roryokane/followers",
        "following_url":"https://api.github.com/users/roryokane/following{/other_user}",
        "gists_url":"https://api.github.com/users/roryokane/gists{/gist_id}",
        "starred_url":"https://api.github.com/users/roryokane/starred{/owner}{/repo}",
        "subscriptions_url":"https://api.github.com/users/roryokane/subscriptions",
        "organizations_url":"https://api.github.com/users/roryokane/orgs",
        "repos_url":"https://api.github.com/users/roryokane/repos",
        "events_url":"https://api.github.com/users/roryokane/events{/privacy}",
        "received_events_url":"https://api.github.com/users/roryokane/received_events",
        "type":"User",
        "site_admin":false
      },
      "created_at":"2020-05-29 19:09:33 UTC",
      "updated_at":"2020-05-29 19:10:56 UTC",
      "author_association":"CONTRIBUTOR",
      "body":"In the current implementation of the parser, I’ve handled incomplete syntax not with a special “incomplete” type of AST, but by interpreting the syntax as valid plaintext. This is the same way Markdown (at least [CommonMark](https://spec.commonmark.org/dingus/)) handles syntax errors.\r\n\r\nI can explain how it works with a simplified version of the parser:\r\n\r\n~~~\r\nblock = ( block-link / any-char )*\r\nblock-link = <'[['> any-chars <']]'>\r\n~~~\r\n\r\nWithin the `*` repetition, `block` uses ordered alternation `/` to attempt to match the following characters to a `block-link` – `[[` and `]]` with character between them – first. If `block-link` doesn’t match, the parser consumes one more character with `any-char` and repeats.\r\n\r\nThat way, a string like `[[foo]` is ultimately not parsed as a special unterminated link, which I imagine might look like this:\r\n\r\n~~~clj\r\n[:block [:error-unterminated [:block-link \"foo]\"]]]\r\n~~~\r\n\r\nRather, it’s interpreted as the literal text “[[foo]”, like this:\r\n\r\n~~~clj\r\n[:block \"[[foo]\"]\r\n~~~\r\n\r\nAccepting the syntax as plain text is much easier to implement than trying to detect and correct errors. Accepting the syntax as plain text also ensures that the author’s punctuation will never be hidden by being misinterpreted as incomplete syntax. The downside is that this parser can’t be used to provide error messages in the case that the user truly wanted to use the link syntax.",
      "performed_via_github_app":null
    }
  ]
}
